{
  "contract_name": "cw-headstash",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "claim_msg_plaintext",
      "multiplier",
      "owner",
      "random_key",
      "snip120u_code_hash",
      "snips"
    ],
    "properties": {
      "bloom_config": {
        "description": "optional bloom configuration",
        "anyOf": [
          {
            "$ref": "#/definitions/BloomConfig"
          },
          {
            "type": "null"
          }
        ]
      },
      "claim_msg_plaintext": {
        "description": "HREAM ~ {wallet} ~ {secondary_addr} ~ {expiration}",
        "type": "string"
      },
      "end_date": {
        "description": "optional date that once reached, will end headstash distribution event.",
        "type": [
          "integer",
          "null"
        ],
        "format": "uint64",
        "minimum": 0.0
      },
      "multiplier": {
        "description": "Option to enable contract to add multiplier on allocations when claiming. currently 1.33x.",
        "type": "boolean"
      },
      "owner": {
        "description": "owner of contract",
        "allOf": [
          {
            "$ref": "#/definitions/Addr"
          }
        ]
      },
      "random_key": {
        "description": "random seed provided by user.",
        "type": "string"
      },
      "snip120u_code_hash": {
        "description": "code hash of custom snip20 contract for headstashes",
        "type": "string"
      },
      "snips": {
        "description": "A list of custom snip20-headstash contracts. This contract must be set as an authorized minter for each, or else this contract will not work.",
        "type": "array",
        "items": {
          "$ref": "#/definitions/Snip120u"
        }
      },
      "start_date": {
        "description": "optional date that once reached, will start headstash distribution event.",
        "type": [
          "integer",
          "null"
        ],
        "format": "uint64",
        "minimum": 0.0
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "BloomConfig": {
        "type": "object",
        "required": [
          "default_cadance",
          "max_granularity",
          "min_cadance"
        ],
        "properties": {
          "default_cadance": {
            "description": "minimum cadance before messages are eligible to be added to mempool (in blocks)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "max_granularity": {
            "description": "maximum number of transactions a bloom msg will process",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "min_cadance": {
            "description": "minimum cadance that can be set before messages are eligible for mempool. if 0, default_cadance is set.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        }
      },
      "Snip120u": {
        "type": "object",
        "required": [
          "addr",
          "native_token",
          "total_amount"
        ],
        "properties": {
          "addr": {
            "description": "smart contract addr of snip120u",
            "allOf": [
              {
                "$ref": "#/definitions/Addr"
              }
            ]
          },
          "native_token": {
            "description": "native x/bank token denomination for this snip120u",
            "type": "string"
          },
          "total_amount": {
            "$ref": "#/definitions/Uint128"
          }
        }
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use secret_cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Admin function to add eligible addrs for each snip120u availables amount.",
        "type": "object",
        "required": [
          "add_eligible_head_stash"
        ],
        "properties": {
          "add_eligible_head_stash": {
            "type": "object",
            "required": [
              "headstash"
            ],
            "properties": {
              "headstash": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Headstash"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Eligible address are able to claim by providing the offline signature and the public address that generated it.",
        "type": "object",
        "required": [
          "claim"
        ],
        "properties": {
          "claim": {
            "type": "object",
            "required": [
              "sig",
              "sig_addr"
            ],
            "properties": {
              "sig": {
                "type": "string"
              },
              "sig_addr": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "clawback"
        ],
        "properties": {
          "clawback": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "register_bloom"
        ],
        "properties": {
          "register_bloom": {
            "type": "object",
            "required": [
              "bloom_msg"
            ],
            "properties": {
              "bloom_msg": {
                "$ref": "#/definitions/BloomMsg"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "prepare_bloom"
        ],
        "properties": {
          "prepare_bloom": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "process_bloom"
        ],
        "properties": {
          "process_bloom": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "BloomMsg": {
        "type": "object",
        "required": [
          "batch_amnt",
          "blooms",
          "cadance",
          "entropy_key",
          "owner",
          "snip120u_addr",
          "total"
        ],
        "properties": {
          "batch_amnt": {
            "description": "amount of tx to process per batch",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "blooms": {
            "description": "recipient and amount to send.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/BloomRecipient"
            }
          },
          "cadance": {
            "description": "additional delay before including blooms into msgs (in blocks)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "entropy_key": {
            "description": "ratio used to classify bloom-mempool tx priority\\ 0 == no entropy, most chance of being included in finality process.\\ 10 == maximize entropy, least possible chance of being included in finality process",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "owner": {
            "description": "owner of snip120u (needed for RedeemFrom)",
            "type": "string"
          },
          "snip120u_addr": {
            "description": "the snip120 to redeem and use in bloom.",
            "type": "string"
          },
          "total": {
            "description": "total amount to be sent via bloom protocol. Must never be greater than allowance set for headstash contract.",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          }
        }
      },
      "BloomRecipient": {
        "type": "object",
        "required": [
          "addr",
          "amount"
        ],
        "properties": {
          "addr": {
            "description": "recipient addr",
            "type": "string"
          },
          "amount": {
            "description": "amount pending to send to recipient.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        }
      },
      "Headstash": {
        "type": "object",
        "required": [
          "addr",
          "snips"
        ],
        "properties": {
          "addr": {
            "type": "string"
          },
          "snips": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Snip"
            }
          }
        }
      },
      "Snip": {
        "type": "object",
        "required": [
          "amount",
          "contract"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "contract": {
            "type": "string"
          }
        }
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use secret_cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "dates"
        ],
        "properties": {
          "dates": {
            "type": "object"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "clawback"
        ],
        "properties": {
          "clawback": {
            "type": "object"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "allocation"
        ],
        "properties": {
          "allocation": {
            "type": "object",
            "required": [
              "addr"
            ],
            "properties": {
              "addr": {
                "type": "string"
              }
            }
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "migrate"
        ],
        "properties": {
          "migrate": {
            "type": "object"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "std_error"
        ],
        "properties": {
          "std_error": {
            "type": "object"
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "sudo": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "SudoMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "handle_ibc_bloom"
        ],
        "properties": {
          "handle_ibc_bloom": {
            "type": "object"
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "responses": {
    "allocation": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "QueryAnswer",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "config_response"
          ],
          "properties": {
            "config_response": {
              "type": "object",
              "required": [
                "config"
              ],
              "properties": {
                "config": {
                  "$ref": "#/definitions/Config"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "dates_response"
          ],
          "properties": {
            "dates_response": {
              "type": "object",
              "required": [
                "start"
              ],
              "properties": {
                "end": {
                  "type": [
                    "integer",
                    "null"
                  ],
                  "format": "uint64",
                  "minimum": 0.0
                },
                "start": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "clawback_response"
          ],
          "properties": {
            "clawback_response": {
              "type": "object",
              "required": [
                "bool"
              ],
              "properties": {
                "bool": {
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "allocation_response"
          ],
          "properties": {
            "allocation_response": {
              "type": "object",
              "required": [
                "amount"
              ],
              "properties": {
                "amount": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "BloomConfig": {
          "type": "object",
          "required": [
            "default_cadance",
            "max_granularity",
            "min_cadance"
          ],
          "properties": {
            "default_cadance": {
              "description": "minimum cadance before messages are eligible to be added to mempool (in blocks)",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "max_granularity": {
              "description": "maximum number of transactions a bloom msg will process",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "min_cadance": {
              "description": "minimum cadance that can be set before messages are eligible for mempool. if 0, default_cadance is set.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Config": {
          "type": "object",
          "required": [
            "claim_msg_plaintext",
            "multiplier",
            "owner",
            "snip120us",
            "snip_hash",
            "start_date"
          ],
          "properties": {
            "bloom": {
              "anyOf": [
                {
                  "$ref": "#/definitions/BloomConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "claim_msg_plaintext": {
              "type": "string"
            },
            "end_date": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "multiplier": {
              "type": "boolean"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "snip120us": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Snip120u"
              }
            },
            "snip_hash": {
              "type": "string"
            },
            "start_date": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Snip120u": {
          "type": "object",
          "required": [
            "addr",
            "native_token",
            "total_amount"
          ],
          "properties": {
            "addr": {
              "description": "smart contract addr of snip120u",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "native_token": {
              "description": "native x/bank token denomination for this snip120u",
              "type": "string"
            },
            "total_amount": {
              "$ref": "#/definitions/Uint128"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use secret_cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "clawback": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "QueryAnswer",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "config_response"
          ],
          "properties": {
            "config_response": {
              "type": "object",
              "required": [
                "config"
              ],
              "properties": {
                "config": {
                  "$ref": "#/definitions/Config"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "dates_response"
          ],
          "properties": {
            "dates_response": {
              "type": "object",
              "required": [
                "start"
              ],
              "properties": {
                "end": {
                  "type": [
                    "integer",
                    "null"
                  ],
                  "format": "uint64",
                  "minimum": 0.0
                },
                "start": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "clawback_response"
          ],
          "properties": {
            "clawback_response": {
              "type": "object",
              "required": [
                "bool"
              ],
              "properties": {
                "bool": {
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "allocation_response"
          ],
          "properties": {
            "allocation_response": {
              "type": "object",
              "required": [
                "amount"
              ],
              "properties": {
                "amount": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "BloomConfig": {
          "type": "object",
          "required": [
            "default_cadance",
            "max_granularity",
            "min_cadance"
          ],
          "properties": {
            "default_cadance": {
              "description": "minimum cadance before messages are eligible to be added to mempool (in blocks)",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "max_granularity": {
              "description": "maximum number of transactions a bloom msg will process",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "min_cadance": {
              "description": "minimum cadance that can be set before messages are eligible for mempool. if 0, default_cadance is set.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Config": {
          "type": "object",
          "required": [
            "claim_msg_plaintext",
            "multiplier",
            "owner",
            "snip120us",
            "snip_hash",
            "start_date"
          ],
          "properties": {
            "bloom": {
              "anyOf": [
                {
                  "$ref": "#/definitions/BloomConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "claim_msg_plaintext": {
              "type": "string"
            },
            "end_date": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "multiplier": {
              "type": "boolean"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "snip120us": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Snip120u"
              }
            },
            "snip_hash": {
              "type": "string"
            },
            "start_date": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Snip120u": {
          "type": "object",
          "required": [
            "addr",
            "native_token",
            "total_amount"
          ],
          "properties": {
            "addr": {
              "description": "smart contract addr of snip120u",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "native_token": {
              "description": "native x/bank token denomination for this snip120u",
              "type": "string"
            },
            "total_amount": {
              "$ref": "#/definitions/Uint128"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use secret_cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "QueryAnswer",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "config_response"
          ],
          "properties": {
            "config_response": {
              "type": "object",
              "required": [
                "config"
              ],
              "properties": {
                "config": {
                  "$ref": "#/definitions/Config"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "dates_response"
          ],
          "properties": {
            "dates_response": {
              "type": "object",
              "required": [
                "start"
              ],
              "properties": {
                "end": {
                  "type": [
                    "integer",
                    "null"
                  ],
                  "format": "uint64",
                  "minimum": 0.0
                },
                "start": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "clawback_response"
          ],
          "properties": {
            "clawback_response": {
              "type": "object",
              "required": [
                "bool"
              ],
              "properties": {
                "bool": {
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "allocation_response"
          ],
          "properties": {
            "allocation_response": {
              "type": "object",
              "required": [
                "amount"
              ],
              "properties": {
                "amount": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "BloomConfig": {
          "type": "object",
          "required": [
            "default_cadance",
            "max_granularity",
            "min_cadance"
          ],
          "properties": {
            "default_cadance": {
              "description": "minimum cadance before messages are eligible to be added to mempool (in blocks)",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "max_granularity": {
              "description": "maximum number of transactions a bloom msg will process",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "min_cadance": {
              "description": "minimum cadance that can be set before messages are eligible for mempool. if 0, default_cadance is set.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Config": {
          "type": "object",
          "required": [
            "claim_msg_plaintext",
            "multiplier",
            "owner",
            "snip120us",
            "snip_hash",
            "start_date"
          ],
          "properties": {
            "bloom": {
              "anyOf": [
                {
                  "$ref": "#/definitions/BloomConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "claim_msg_plaintext": {
              "type": "string"
            },
            "end_date": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "multiplier": {
              "type": "boolean"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "snip120us": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Snip120u"
              }
            },
            "snip_hash": {
              "type": "string"
            },
            "start_date": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Snip120u": {
          "type": "object",
          "required": [
            "addr",
            "native_token",
            "total_amount"
          ],
          "properties": {
            "addr": {
              "description": "smart contract addr of snip120u",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "native_token": {
              "description": "native x/bank token denomination for this snip120u",
              "type": "string"
            },
            "total_amount": {
              "$ref": "#/definitions/Uint128"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use secret_cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "dates": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "QueryAnswer",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "config_response"
          ],
          "properties": {
            "config_response": {
              "type": "object",
              "required": [
                "config"
              ],
              "properties": {
                "config": {
                  "$ref": "#/definitions/Config"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "dates_response"
          ],
          "properties": {
            "dates_response": {
              "type": "object",
              "required": [
                "start"
              ],
              "properties": {
                "end": {
                  "type": [
                    "integer",
                    "null"
                  ],
                  "format": "uint64",
                  "minimum": 0.0
                },
                "start": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "clawback_response"
          ],
          "properties": {
            "clawback_response": {
              "type": "object",
              "required": [
                "bool"
              ],
              "properties": {
                "bool": {
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "allocation_response"
          ],
          "properties": {
            "allocation_response": {
              "type": "object",
              "required": [
                "amount"
              ],
              "properties": {
                "amount": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "BloomConfig": {
          "type": "object",
          "required": [
            "default_cadance",
            "max_granularity",
            "min_cadance"
          ],
          "properties": {
            "default_cadance": {
              "description": "minimum cadance before messages are eligible to be added to mempool (in blocks)",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "max_granularity": {
              "description": "maximum number of transactions a bloom msg will process",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "min_cadance": {
              "description": "minimum cadance that can be set before messages are eligible for mempool. if 0, default_cadance is set.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Config": {
          "type": "object",
          "required": [
            "claim_msg_plaintext",
            "multiplier",
            "owner",
            "snip120us",
            "snip_hash",
            "start_date"
          ],
          "properties": {
            "bloom": {
              "anyOf": [
                {
                  "$ref": "#/definitions/BloomConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "claim_msg_plaintext": {
              "type": "string"
            },
            "end_date": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "multiplier": {
              "type": "boolean"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "snip120us": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Snip120u"
              }
            },
            "snip_hash": {
              "type": "string"
            },
            "start_date": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Snip120u": {
          "type": "object",
          "required": [
            "addr",
            "native_token",
            "total_amount"
          ],
          "properties": {
            "addr": {
              "description": "smart contract addr of snip120u",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "native_token": {
              "description": "native x/bank token denomination for this snip120u",
              "type": "string"
            },
            "total_amount": {
              "$ref": "#/definitions/Uint128"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use secret_cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
