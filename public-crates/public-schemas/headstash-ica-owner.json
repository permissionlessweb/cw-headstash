{
  "contract_name": "headstash-ica-owner",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "headstash_params",
      "ica_controller_code_id"
    ],
    "properties": {
      "feegranter": {
        "description": "Eligible address able to authorize feegrants on behalf of the ICA.",
        "type": [
          "string",
          "null"
        ]
      },
      "headstash_params": {
        "description": "Parameters for the cw-headstash contract",
        "allOf": [
          {
            "$ref": "#/definitions/HeadstashParams"
          }
        ]
      },
      "ica_controller_code_id": {
        "description": "Code-id off the cw-ica-controller contract",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "owner": {
        "description": "Owner of this contract, and any ICA account created by this contract.",
        "type": [
          "string",
          "null"
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "BloomConfig": {
        "type": "object",
        "required": [
          "default_cadance",
          "max_granularity",
          "min_cadance"
        ],
        "properties": {
          "default_cadance": {
            "description": "minimum cadance before messages are eligible to be added to mempool (in blocks)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "max_granularity": {
            "description": "maximum number of transactions a bloom msg will process",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "min_cadance": {
            "description": "minimum cadance that can be set before messages are eligible for mempool. if 0, default_cadance is set.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "HeadstashInitConfig": {
        "type": "object",
        "required": [
          "claim_msg_plaintxt",
          "random_key"
        ],
        "properties": {
          "claim_msg_plaintxt": {
            "type": "string"
          },
          "end_date": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "random_key": {
            "type": "string"
          },
          "start_date": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "HeadstashParams": {
        "description": "Params for Headstash",
        "type": "object",
        "required": [
          "cw_glob",
          "headstash_init_config",
          "multiplier",
          "snip120u_code_hash",
          "snip120u_code_id",
          "token_params"
        ],
        "properties": {
          "bloom_config": {
            "description": "bloom config",
            "anyOf": [
              {
                "$ref": "#/definitions/BloomConfig"
              },
              {
                "type": "null"
              }
            ]
          },
          "cw_glob": {
            "description": "The contract addr for cw-glob on the native chain.",
            "allOf": [
              {
                "$ref": "#/definitions/Addr"
              }
            ]
          },
          "fee_granter": {
            "description": "The wallet address able to create feegrant authorizations on behalf of this contract",
            "type": [
              "string",
              "null"
            ]
          },
          "headstash_addr": {
            "description": "Headstash contract address this contract is admin of. We save this address in the first callback msg sent during setup_headstash, and then use it to set as admin for snip120u of assets after 1st callback.",
            "type": [
              "string",
              "null"
            ]
          },
          "headstash_code_id": {
            "description": "Code id of Headstash contract on Secret Network",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "headstash_init_config": {
            "$ref": "#/definitions/HeadstashInitConfig"
          },
          "multiplier": {
            "description": "Enables reward multiplier for cw-headstash",
            "type": "boolean"
          },
          "snip120u_code_hash": {
            "description": "The code hash of the snip120u contract, on Secret Network. Not optional for pre-deployment verification",
            "type": "string"
          },
          "snip120u_code_id": {
            "description": "The code ID of the snip120u contract, on Secret Network.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "token_params": {
            "description": "Params defined by deployer for tokens included.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/HeadstashTokenParams"
            }
          }
        },
        "additionalProperties": false
      },
      "HeadstashTokenParams": {
        "description": "Params for Headstash Tokens",
        "type": "object",
        "required": [
          "ibc",
          "name",
          "native",
          "source_channel",
          "symbol",
          "total"
        ],
        "properties": {
          "ibc": {
            "description": "ibc string on Secret",
            "type": "string"
          },
          "name": {
            "description": "Name to use in snip120u state",
            "type": "string"
          },
          "native": {
            "description": "native token name",
            "type": "string"
          },
          "snip_addr": {
            "description": "snip20 addr on Secret",
            "type": [
              "string",
              "null"
            ]
          },
          "source_channel": {
            "description": "canonical source channel of token for transfers from source to secret network",
            "type": "string"
          },
          "symbol": {
            "description": "Symbol to use",
            "type": "string"
          },
          "total": {
            "description": "Total amount for specific snip",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Creates the ica-controller & initiates the ica creation workflow",
        "type": "object",
        "required": [
          "create_ica_contract"
        ],
        "properties": {
          "create_ica_contract": {
            "type": "object",
            "required": [
              "channel_open_init_options"
            ],
            "properties": {
              "channel_open_init_options": {
                "$ref": "#/definitions/ChannelOpenInitOptions"
              },
              "headstash_params": {
                "description": "If none is set, loads headstash params from contract state.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/HeadstashParams"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "salt": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Sets the cw-glob contract address to GLOBAL_CONTRACT_STATE 1. Upload the following contracts in the expected sequence: a. snip120u b. cw-headstash",
        "type": "object",
        "required": [
          "upload_contract_on_secret"
        ],
        "properties": {
          "upload_contract_on_secret": {
            "type": "object",
            "required": [
              "wasm"
            ],
            "properties": {
              "cw_glob": {
                "description": "Optional contract address of the cw-glob.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "wasm": {
                "description": "The wasm blob name to upload",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "2. Instantiate a snip120u contract for every token defined in tokens.",
        "type": "object",
        "required": [
          "init_snip120u"
        ],
        "properties": {
          "init_snip120u": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "3. Instantiates the secret headstash contract on Secret Network.",
        "type": "object",
        "required": [
          "init_headstash"
        ],
        "properties": {
          "init_headstash": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "4. Authorized the headstash contract as a minter for both snip120u contracts.",
        "type": "object",
        "required": [
          "authorize_headstash_as_snip_minter"
        ],
        "properties": {
          "authorize_headstash_as_snip_minter": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": ". Transfer each token included in msg over via ics20.",
        "type": "object",
        "required": [
          "ibc_transfer_tokens"
        ],
        "properties": {
          "ibc_transfer_tokens": {
            "type": "object",
            "required": [
              "channel_id"
            ],
            "properties": {
              "channel_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "8. Add Eligible Addresses To Headstash",
        "type": "object",
        "required": [
          "add_headstash_claimers"
        ],
        "properties": {
          "add_headstash_claimers": {
            "type": "object",
            "required": [
              "to_add"
            ],
            "properties": {
              "to_add": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Headstash"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "9. Authorize secret network wallet with feegrant",
        "type": "object",
        "required": [
          "authorize_feegrant"
        ],
        "properties": {
          "authorize_feegrant": {
            "type": "object",
            "required": [
              "to_grant"
            ],
            "properties": {
              "owner": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "to_grant": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "10. Grant authorization to perform actions on behalf of ica-addr",
        "type": "object",
        "required": [
          "authz_deployer"
        ],
        "properties": {
          "authz_deployer": {
            "type": "object",
            "required": [
              "grantee"
            ],
            "properties": {
              "grantee": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "set_headstash_code_id"
        ],
        "properties": {
          "set_headstash_code_id": {
            "type": "object",
            "required": [
              "code_id"
            ],
            "properties": {
              "code_id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "set_snip120u_code_id"
        ],
        "properties": {
          "set_snip120u_code_id": {
            "type": "object",
            "required": [
              "code_id"
            ],
            "properties": {
              "code_id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "set_headstash_addr"
        ],
        "properties": {
          "set_headstash_addr": {
            "type": "object",
            "required": [
              "addr"
            ],
            "properties": {
              "addr": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "set_snip120u_addr"
        ],
        "properties": {
          "set_snip120u_addr": {
            "type": "object",
            "required": [
              "addr",
              "denom"
            ],
            "properties": {
              "addr": {
                "description": "contract addr of snip",
                "type": "string"
              },
              "denom": {
                "description": "token denomination representing snip",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "The callback message from `cw-ica-controller`. The handler for this variant should verify that this message comes from an expected legitimate source.",
        "type": "object",
        "required": [
          "receive_ica_callback"
        ],
        "properties": {
          "receive_ica_callback": {
            "$ref": "#/definitions/IcaControllerCallbackMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update the contract's ownership. The `action` to be provided can be either to propose transferring ownership to an account, accept a pending ownership transfer, or renounce the ownership permanently.",
        "type": "object",
        "required": [
          "update_ownership"
        ],
        "properties": {
          "update_ownership": {
            "$ref": "#/definitions/Action"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Action": {
        "description": "Actions that can be taken to alter the contract's ownership",
        "oneOf": [
          {
            "description": "Propose to transfer the contract's ownership to another account, optionally with an expiry time.\n\nCan only be called by the contract's current owner.\n\nAny existing pending ownership transfer is overwritten.",
            "type": "object",
            "required": [
              "transfer_ownership"
            ],
            "properties": {
              "transfer_ownership": {
                "type": "object",
                "required": [
                  "new_owner"
                ],
                "properties": {
                  "expiry": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "new_owner": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Accept the pending ownership transfer.\n\nCan only be called by the pending owner.",
            "type": "string",
            "enum": [
              "accept_ownership"
            ]
          },
          {
            "description": "Give up the contract's ownership and the possibility of appointing a new owner.\n\nCan only be invoked by the contract's current owner.\n\nAny existing pending ownership transfer is canceled.",
            "type": "string",
            "enum": [
              "renounce_ownership"
            ]
          }
        ]
      },
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "AllBalanceResponse": {
        "type": "object",
        "required": [
          "amount"
        ],
        "properties": {
          "amount": {
            "description": "Returns all non-zero coins held by this account.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          }
        },
        "additionalProperties": false
      },
      "AllDenomMetadataResponse": {
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "metadata": {
            "description": "Always returns metadata for all token denoms on the base chain.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/DenomMetadata"
            }
          },
          "next_key": {
            "anyOf": [
              {
                "$ref": "#/definitions/Binary"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "AllValidatorsResponse": {
        "description": "The data format returned from StakingRequest::AllValidators query",
        "type": "object",
        "required": [
          "validators"
        ],
        "properties": {
          "validators": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Validator"
            }
          }
        },
        "additionalProperties": false
      },
      "BalanceResponse": {
        "type": "object",
        "required": [
          "amount"
        ],
        "properties": {
          "amount": {
            "description": "Always returns a Coin with the requested denom. This may be of 0 amount if no such funds.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "BankQueryResponse": {
        "description": "The response type for the [`cosmwasm_std::BankQuery`] queries.",
        "oneOf": [
          {
            "description": "Response for the [`cosmwasm_std::BankQuery::Supply`] query.",
            "type": "object",
            "required": [
              "supply"
            ],
            "properties": {
              "supply": {
                "$ref": "#/definitions/SupplyResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::BankQuery::Balance`] query.",
            "type": "object",
            "required": [
              "balance"
            ],
            "properties": {
              "balance": {
                "$ref": "#/definitions/BalanceResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::BankQuery::AllBalances`] query.",
            "type": "object",
            "required": [
              "all_balances"
            ],
            "properties": {
              "all_balances": {
                "$ref": "#/definitions/AllBalanceResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::BankQuery::DenomMetadata`] query.",
            "type": "object",
            "required": [
              "denom_metadata"
            ],
            "properties": {
              "denom_metadata": {
                "$ref": "#/definitions/DenomMetadataResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::BankQuery::AllDenomMetadata`] query.",
            "type": "object",
            "required": [
              "all_denom_metadata"
            ],
            "properties": {
              "all_denom_metadata": {
                "$ref": "#/definitions/AllDenomMetadataResponse"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "BloomConfig": {
        "type": "object",
        "required": [
          "default_cadance",
          "max_granularity",
          "min_cadance"
        ],
        "properties": {
          "default_cadance": {
            "description": "minimum cadance before messages are eligible to be added to mempool (in blocks)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "max_granularity": {
            "description": "maximum number of transactions a bloom msg will process",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "min_cadance": {
            "description": "minimum cadance that can be set before messages are eligible for mempool. if 0, default_cadance is set.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "BondedDenomResponse": {
        "description": "BondedDenomResponse is data format returned from StakingRequest::BondedDenom query",
        "type": "object",
        "required": [
          "denom"
        ],
        "properties": {
          "denom": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "ChannelOpenInitOptions": {
        "description": "The options needed to initialize the IBC channel.",
        "type": "object",
        "required": [
          "connection_id",
          "counterparty_connection_id"
        ],
        "properties": {
          "channel_ordering": {
            "description": "The order of the channel. If not specified, [`IbcOrder::Ordered`] is used. [`IbcOrder::Unordered`] is only supported if the counterparty chain is using `ibc-go` v8.1.0 or later.",
            "anyOf": [
              {
                "$ref": "#/definitions/IbcOrder"
              },
              {
                "type": "null"
              }
            ]
          },
          "connection_id": {
            "description": "The connection id on this chain.",
            "type": "string"
          },
          "counterparty_connection_id": {
            "description": "The counterparty connection id on the counterparty chain.",
            "type": "string"
          },
          "counterparty_port_id": {
            "description": "The counterparty port id. If not specified, [`crate::ibc::types::keys::HOST_PORT_ID`] is used. Currently, this contract only supports the host port.",
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "Checksum": {
        "description": "A SHA-256 checksum of a Wasm blob, used to identify a Wasm code. This must remain stable since this checksum is stored in the blockchain state.\n\nThis is often referred to as \"code ID\" in go-cosmwasm, even if code ID usually refers to an auto-incrementing number.",
        "type": "string"
      },
      "CodeInfoResponse": {
        "description": "The essential data from wasmd's [CodeInfo]/[CodeInfoResponse].\n\n`code_hash`/`data_hash` was renamed to `checksum` to follow the CosmWasm convention and naming in `instantiate2_address`.\n\n[CodeInfo]: https://github.com/CosmWasm/wasmd/blob/v0.30.0/proto/cosmwasm/wasm/v1/types.proto#L62-L72 [CodeInfoResponse]: https://github.com/CosmWasm/wasmd/blob/v0.30.0/proto/cosmwasm/wasm/v1/query.proto#L184-L199",
        "type": "object",
        "required": [
          "checksum",
          "code_id",
          "creator"
        ],
        "properties": {
          "checksum": {
            "description": "The hash of the Wasm blob",
            "allOf": [
              {
                "$ref": "#/definitions/Checksum"
              }
            ]
          },
          "code_id": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "creator": {
            "description": "The address that initially stored the code",
            "allOf": [
              {
                "$ref": "#/definitions/Addr"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "ContractInfoResponse": {
        "type": "object",
        "required": [
          "code_id",
          "creator",
          "pinned"
        ],
        "properties": {
          "admin": {
            "description": "admin who can run migrations (if any)",
            "anyOf": [
              {
                "$ref": "#/definitions/Addr"
              },
              {
                "type": "null"
              }
            ]
          },
          "code_id": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "creator": {
            "description": "address that instantiated this contract",
            "allOf": [
              {
                "$ref": "#/definitions/Addr"
              }
            ]
          },
          "ibc_port": {
            "description": "set if this contract has bound an IBC port",
            "type": [
              "string",
              "null"
            ]
          },
          "pinned": {
            "description": "if set, the contract is pinned to the cache, and thus uses less gas when called",
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "Data": {
        "description": "`Data` is the response to an ibc packet. It either contains a result or an error.",
        "oneOf": [
          {
            "description": "Result is the result of a successful transaction.",
            "type": "object",
            "required": [
              "result"
            ],
            "properties": {
              "result": {
                "$ref": "#/definitions/Binary"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Error is the error message of a failed transaction. It is a string of the error message (not base64 encoded).",
            "type": "object",
            "required": [
              "error"
            ],
            "properties": {
              "error": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Delegation": {
        "description": "Delegation is the detailed information about a delegation.",
        "type": "object",
        "required": [
          "amount",
          "delegator",
          "validator"
        ],
        "properties": {
          "amount": {
            "description": "Delegation amount.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "delegator": {
            "description": "The delegator address.",
            "type": "string"
          },
          "validator": {
            "description": "A validator address (e.g. cosmosvaloper1...)",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "DenomMetadata": {
        "description": "Replicates the cosmos-sdk bank module Metadata type",
        "type": "object",
        "required": [
          "base",
          "denom_units",
          "description",
          "display",
          "name",
          "symbol",
          "uri",
          "uri_hash"
        ],
        "properties": {
          "base": {
            "type": "string"
          },
          "denom_units": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/DenomUnit"
            }
          },
          "description": {
            "type": "string"
          },
          "display": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "symbol": {
            "type": "string"
          },
          "uri": {
            "type": "string"
          },
          "uri_hash": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "DenomMetadataResponse": {
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "metadata": {
            "description": "The metadata for the queried denom.",
            "allOf": [
              {
                "$ref": "#/definitions/DenomMetadata"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "DenomUnit": {
        "description": "Replicates the cosmos-sdk bank module DenomUnit type",
        "type": "object",
        "required": [
          "aliases",
          "denom",
          "exponent"
        ],
        "properties": {
          "aliases": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "denom": {
            "type": "string"
          },
          "exponent": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Headstash": {
        "type": "object",
        "required": [
          "pubkey",
          "snips"
        ],
        "properties": {
          "pubkey": {
            "type": "string"
          },
          "snips": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Snip"
            }
          }
        },
        "additionalProperties": false
      },
      "HeadstashInitConfig": {
        "type": "object",
        "required": [
          "claim_msg_plaintxt",
          "random_key"
        ],
        "properties": {
          "claim_msg_plaintxt": {
            "type": "string"
          },
          "end_date": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "random_key": {
            "type": "string"
          },
          "start_date": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "HeadstashParams": {
        "description": "Params for Headstash",
        "type": "object",
        "required": [
          "cw_glob",
          "headstash_init_config",
          "multiplier",
          "snip120u_code_hash",
          "snip120u_code_id",
          "token_params"
        ],
        "properties": {
          "bloom_config": {
            "description": "bloom config",
            "anyOf": [
              {
                "$ref": "#/definitions/BloomConfig"
              },
              {
                "type": "null"
              }
            ]
          },
          "cw_glob": {
            "description": "The contract addr for cw-glob on the native chain.",
            "allOf": [
              {
                "$ref": "#/definitions/Addr"
              }
            ]
          },
          "fee_granter": {
            "description": "The wallet address able to create feegrant authorizations on behalf of this contract",
            "type": [
              "string",
              "null"
            ]
          },
          "headstash_addr": {
            "description": "Headstash contract address this contract is admin of. We save this address in the first callback msg sent during setup_headstash, and then use it to set as admin for snip120u of assets after 1st callback.",
            "type": [
              "string",
              "null"
            ]
          },
          "headstash_code_id": {
            "description": "Code id of Headstash contract on Secret Network",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "headstash_init_config": {
            "$ref": "#/definitions/HeadstashInitConfig"
          },
          "multiplier": {
            "description": "Enables reward multiplier for cw-headstash",
            "type": "boolean"
          },
          "snip120u_code_hash": {
            "description": "The code hash of the snip120u contract, on Secret Network. Not optional for pre-deployment verification",
            "type": "string"
          },
          "snip120u_code_id": {
            "description": "The code ID of the snip120u contract, on Secret Network.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "token_params": {
            "description": "Params defined by deployer for tokens included.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/HeadstashTokenParams"
            }
          }
        },
        "additionalProperties": false
      },
      "HeadstashTokenParams": {
        "description": "Params for Headstash Tokens",
        "type": "object",
        "required": [
          "ibc",
          "name",
          "native",
          "source_channel",
          "symbol",
          "total"
        ],
        "properties": {
          "ibc": {
            "description": "ibc string on Secret",
            "type": "string"
          },
          "name": {
            "description": "Name to use in snip120u state",
            "type": "string"
          },
          "native": {
            "description": "native token name",
            "type": "string"
          },
          "snip_addr": {
            "description": "snip20 addr on Secret",
            "type": [
              "string",
              "null"
            ]
          },
          "source_channel": {
            "description": "canonical source channel of token for transfers from source to secret network",
            "type": "string"
          },
          "symbol": {
            "description": "Symbol to use",
            "type": "string"
          },
          "total": {
            "description": "Total amount for specific snip",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "IbcChannel": {
        "description": "IbcChannel defines all information on a channel. This is generally used in the hand-shake process, but can be queried directly.",
        "type": "object",
        "required": [
          "connection_id",
          "counterparty_endpoint",
          "endpoint",
          "order",
          "version"
        ],
        "properties": {
          "connection_id": {
            "description": "The connection upon which this channel was created. If this is a multi-hop channel, we only expose the first hop.",
            "type": "string"
          },
          "counterparty_endpoint": {
            "$ref": "#/definitions/IbcEndpoint"
          },
          "endpoint": {
            "$ref": "#/definitions/IbcEndpoint"
          },
          "order": {
            "$ref": "#/definitions/IbcOrder"
          },
          "version": {
            "description": "Note: in ibcv3 this may be \"\", in the IbcOpenChannel handshake messages",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "IbcEndpoint": {
        "type": "object",
        "required": [
          "channel_id",
          "port_id"
        ],
        "properties": {
          "channel_id": {
            "type": "string"
          },
          "port_id": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "IbcOrder": {
        "description": "IbcOrder defines if a channel is ORDERED or UNORDERED Values come from https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/core/channel/v1/channel.proto#L69-L80 Naming comes from the protobuf files and go translations.",
        "type": "string",
        "enum": [
          "ORDER_UNORDERED",
          "ORDER_ORDERED"
        ]
      },
      "IbcPacket": {
        "type": "object",
        "required": [
          "data",
          "dest",
          "sequence",
          "src",
          "timeout"
        ],
        "properties": {
          "data": {
            "description": "The raw data sent from the other side in the packet",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          },
          "dest": {
            "description": "identifies the channel and port on the receiving chain.",
            "allOf": [
              {
                "$ref": "#/definitions/IbcEndpoint"
              }
            ]
          },
          "sequence": {
            "description": "The sequence number of the packet on the given channel",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "src": {
            "description": "identifies the channel and port on the sending chain.",
            "allOf": [
              {
                "$ref": "#/definitions/IbcEndpoint"
              }
            ]
          },
          "timeout": {
            "$ref": "#/definitions/IbcTimeout"
          }
        },
        "additionalProperties": false
      },
      "IbcTimeout": {
        "description": "In IBC each package must set at least one type of timeout: the timestamp or the block height. Using this rather complex enum instead of two timeout fields we ensure that at least one timeout is set.",
        "type": "object",
        "properties": {
          "block": {
            "anyOf": [
              {
                "$ref": "#/definitions/IbcTimeoutBlock"
              },
              {
                "type": "null"
              }
            ]
          },
          "timestamp": {
            "anyOf": [
              {
                "$ref": "#/definitions/Timestamp"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "IbcTimeoutBlock": {
        "description": "IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)",
        "type": "object",
        "required": [
          "height",
          "revision"
        ],
        "properties": {
          "height": {
            "description": "block height after which the packet times out. the height within the given revision",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "revision": {
            "description": "the version that the client is currently on (e.g. after resetting the chain this could increment 1 as height drops to 0)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "IcaAllDelegationsResponse": {
        "description": "Response for the [`cosmwasm_std::StakingQuery::AllDelegations`] query over ICA.",
        "type": "object",
        "required": [
          "delegations"
        ],
        "properties": {
          "delegations": {
            "description": "The delegations.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Delegation"
            }
          }
        },
        "additionalProperties": false
      },
      "IcaControllerCallbackMsg": {
        "description": "`IcaControllerCallbackMsg` is the type of message that this contract can send to other contracts.",
        "oneOf": [
          {
            "description": "`OnAcknowledgementPacketCallback` is the callback that this contract makes to other contracts when it receives an acknowledgement packet.",
            "type": "object",
            "required": [
              "on_acknowledgement_packet_callback"
            ],
            "properties": {
              "on_acknowledgement_packet_callback": {
                "type": "object",
                "required": [
                  "ica_acknowledgement",
                  "original_packet",
                  "relayer"
                ],
                "properties": {
                  "ica_acknowledgement": {
                    "description": "The deserialized ICA acknowledgement data",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Data"
                      }
                    ]
                  },
                  "original_packet": {
                    "description": "The original packet that was sent",
                    "allOf": [
                      {
                        "$ref": "#/definitions/IbcPacket"
                      }
                    ]
                  },
                  "query_result": {
                    "description": "The responses to the queries.",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/IcaQueryResult"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "relayer": {
                    "description": "The relayer that submitted acknowledgement packet",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Addr"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "`OnTimeoutPacketCallback` is the callback that this contract makes to other contracts when it receives a timeout packet.",
            "type": "object",
            "required": [
              "on_timeout_packet_callback"
            ],
            "properties": {
              "on_timeout_packet_callback": {
                "type": "object",
                "required": [
                  "original_packet",
                  "relayer"
                ],
                "properties": {
                  "original_packet": {
                    "description": "The original packet that was sent",
                    "allOf": [
                      {
                        "$ref": "#/definitions/IbcPacket"
                      }
                    ]
                  },
                  "relayer": {
                    "description": "The relayer that submitted acknowledgement packet",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Addr"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "`OnChannelOpenAckCallback` is the callback that this contract makes to other contracts when it receives a channel open acknowledgement.",
            "type": "object",
            "required": [
              "on_channel_open_ack_callback"
            ],
            "properties": {
              "on_channel_open_ack_callback": {
                "type": "object",
                "required": [
                  "channel",
                  "ica_address",
                  "tx_encoding"
                ],
                "properties": {
                  "channel": {
                    "description": "The channel that was opened.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/IbcChannel"
                      }
                    ]
                  },
                  "ica_address": {
                    "description": "The address of the interchain account that was created.",
                    "type": "string"
                  },
                  "tx_encoding": {
                    "description": "The tx encoding this ICA channel uses.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/TxEncoding"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "IcaDelegationResponse": {
        "description": "Response for the [`cosmwasm_std::StakingQuery::Delegation`] query over ICA.",
        "type": "object",
        "properties": {
          "delegation": {
            "description": "The delegation response if it exists.",
            "anyOf": [
              {
                "$ref": "#/definitions/Delegation"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "IcaQueryResponse": {
        "description": "The response for a successful ICA query.",
        "oneOf": [
          {
            "description": "Response for a [`cosmwasm_std::BankQuery`].",
            "type": "object",
            "required": [
              "bank"
            ],
            "properties": {
              "bank": {
                "$ref": "#/definitions/BankQueryResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for a [`cosmwasm_std::QueryRequest::Stargate`]. Protobuf encoded bytes stored as [`cosmwasm_std::Binary`].",
            "type": "object",
            "required": [
              "stargate"
            ],
            "properties": {
              "stargate": {
                "type": "object",
                "required": [
                  "data",
                  "path"
                ],
                "properties": {
                  "data": {
                    "description": "The response bytes.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  },
                  "path": {
                    "description": "The query grpc method",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for a [`cosmwasm_std::WasmQuery`].",
            "type": "object",
            "required": [
              "wasm"
            ],
            "properties": {
              "wasm": {
                "$ref": "#/definitions/WasmQueryResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for a [`cosmwasm_std::StakingQuery`].",
            "type": "object",
            "required": [
              "staking"
            ],
            "properties": {
              "staking": {
                "$ref": "#/definitions/StakingQueryResponse"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "IcaQueryResult": {
        "description": "The result of an ICA query packet.",
        "oneOf": [
          {
            "description": "The query was successful and the responses are included.",
            "type": "object",
            "required": [
              "success"
            ],
            "properties": {
              "success": {
                "type": "object",
                "required": [
                  "height",
                  "responses"
                ],
                "properties": {
                  "height": {
                    "description": "The height of the block at which the queries were executed on the counterparty chain.",
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  },
                  "responses": {
                    "description": "The responses to the queries.",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/IcaQueryResponse"
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "The query failed with an error message. The error string often does not contain useful information for the end user.",
            "type": "object",
            "required": [
              "error"
            ],
            "properties": {
              "error": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Snip": {
        "type": "object",
        "required": [
          "addr",
          "amount"
        ],
        "properties": {
          "addr": {
            "type": "string"
          },
          "amount": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "StakingQueryResponse": {
        "description": "The response type for the [`cosmwasm_std::StakingQuery`] queries.",
        "oneOf": [
          {
            "description": "Response for the [`cosmwasm_std::StakingQuery::BondedDenom`] query.",
            "type": "object",
            "required": [
              "bonded_denom"
            ],
            "properties": {
              "bonded_denom": {
                "$ref": "#/definitions/BondedDenomResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::StakingQuery::AllDelegations`] query.",
            "type": "object",
            "required": [
              "all_delegations"
            ],
            "properties": {
              "all_delegations": {
                "$ref": "#/definitions/IcaAllDelegationsResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::StakingQuery::Delegation`] query.",
            "type": "object",
            "required": [
              "delegation"
            ],
            "properties": {
              "delegation": {
                "$ref": "#/definitions/IcaDelegationResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::StakingQuery::AllValidators`] query.",
            "type": "object",
            "required": [
              "all_validators"
            ],
            "properties": {
              "all_validators": {
                "$ref": "#/definitions/AllValidatorsResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::StakingQuery::Validator`] query.",
            "type": "object",
            "required": [
              "validator"
            ],
            "properties": {
              "validator": {
                "$ref": "#/definitions/ValidatorResponse"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "SupplyResponse": {
        "type": "object",
        "required": [
          "amount"
        ],
        "properties": {
          "amount": {
            "description": "Always returns a Coin with the requested denom. This will be of zero amount if the denom does not exist.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "TxEncoding": {
        "description": "`TxEncoding` is the encoding of the transactions sent to the ICA host.",
        "oneOf": [
          {
            "description": "`Protobuf` is the protobuf serialization of the CosmosSDK's Any.",
            "type": "string",
            "enum": [
              "proto3"
            ]
          },
          {
            "description": "`Proto3Json` is the json serialization of the CosmosSDK's Any.",
            "type": "string",
            "enum": [
              "proto3json"
            ]
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      },
      "Validator": {
        "description": "Instances are created in the querier.",
        "type": "object",
        "required": [
          "address",
          "commission",
          "max_change_rate",
          "max_commission"
        ],
        "properties": {
          "address": {
            "description": "The operator address of the validator (e.g. cosmosvaloper1...). See https://github.com/cosmos/cosmos-sdk/blob/v0.47.4/proto/cosmos/staking/v1beta1/staking.proto#L95-L96 for more information.\n\nThis uses `String` instead of `Addr` since the bech32 address prefix is different from the ones that regular user accounts use.",
            "type": "string"
          },
          "commission": {
            "$ref": "#/definitions/Decimal"
          },
          "max_change_rate": {
            "description": "The maximum daily increase of the commission",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "max_commission": {
            "$ref": "#/definitions/Decimal"
          }
        },
        "additionalProperties": false
      },
      "ValidatorResponse": {
        "description": "The data format returned from StakingRequest::Validator query",
        "type": "object",
        "properties": {
          "validator": {
            "anyOf": [
              {
                "$ref": "#/definitions/Validator"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "WasmQueryResponse": {
        "description": "The response type for the [`cosmwasm_std::WasmQuery`] queries.",
        "oneOf": [
          {
            "description": "Response for the [`cosmwasm_std::WasmQuery::ContractInfo`] query. Returns `None` if the contract does not exist. The `pinned` field is not supported.",
            "type": "object",
            "required": [
              "contract_info"
            ],
            "properties": {
              "contract_info": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/ContractInfoResponse"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::WasmQuery::CodeInfo`] query. Returns `None` if the code does not exist.",
            "type": "object",
            "required": [
              "code_info"
            ],
            "properties": {
              "code_info": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/CodeInfoResponse"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::WasmQuery::Raw`] query.",
            "type": "object",
            "required": [
              "raw_contract_state"
            ],
            "properties": {
              "raw_contract_state": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Binary"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Response for the [`cosmwasm_std::WasmQuery::Smart`] query.",
            "type": "object",
            "required": [
              "smart_contract_state"
            ],
            "properties": {
              "smart_contract_state": {
                "$ref": "#/definitions/Binary"
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "GetContractState returns the contact's state.",
        "type": "object",
        "required": [
          "get_contract_state"
        ],
        "properties": {
          "get_contract_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_deployment_state"
        ],
        "properties": {
          "get_deployment_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "GetIcaState returns the ICA state for the given ICA ID.",
        "type": "object",
        "required": [
          "get_ica_contract_state"
        ],
        "properties": {
          "get_ica_contract_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "authz_grantee"
        ],
        "properties": {
          "authz_grantee": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the contract's ownership information",
        "type": "object",
        "required": [
          "ownership"
        ],
        "properties": {
          "ownership": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "authz_grantee": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string"
    },
    "get_contract_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractState",
      "description": "ContractState is the state of the IBC application.",
      "type": "object",
      "required": [
        "default_hs_params",
        "ica_controller_code_id"
      ],
      "properties": {
        "default_hs_params": {
          "$ref": "#/definitions/HeadstashParams"
        },
        "ica_controller_code_id": {
          "description": "The code ID of the cw-ica-controller contract.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "BloomConfig": {
          "type": "object",
          "required": [
            "default_cadance",
            "max_granularity",
            "min_cadance"
          ],
          "properties": {
            "default_cadance": {
              "description": "minimum cadance before messages are eligible to be added to mempool (in blocks)",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "max_granularity": {
              "description": "maximum number of transactions a bloom msg will process",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "min_cadance": {
              "description": "minimum cadance that can be set before messages are eligible for mempool. if 0, default_cadance is set.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "HeadstashInitConfig": {
          "type": "object",
          "required": [
            "claim_msg_plaintxt",
            "random_key"
          ],
          "properties": {
            "claim_msg_plaintxt": {
              "type": "string"
            },
            "end_date": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "random_key": {
              "type": "string"
            },
            "start_date": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "HeadstashParams": {
          "description": "Params for Headstash",
          "type": "object",
          "required": [
            "cw_glob",
            "headstash_init_config",
            "multiplier",
            "snip120u_code_hash",
            "snip120u_code_id",
            "token_params"
          ],
          "properties": {
            "bloom_config": {
              "description": "bloom config",
              "anyOf": [
                {
                  "$ref": "#/definitions/BloomConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "cw_glob": {
              "description": "The contract addr for cw-glob on the native chain.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "fee_granter": {
              "description": "The wallet address able to create feegrant authorizations on behalf of this contract",
              "type": [
                "string",
                "null"
              ]
            },
            "headstash_addr": {
              "description": "Headstash contract address this contract is admin of. We save this address in the first callback msg sent during setup_headstash, and then use it to set as admin for snip120u of assets after 1st callback.",
              "type": [
                "string",
                "null"
              ]
            },
            "headstash_code_id": {
              "description": "Code id of Headstash contract on Secret Network",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "headstash_init_config": {
              "$ref": "#/definitions/HeadstashInitConfig"
            },
            "multiplier": {
              "description": "Enables reward multiplier for cw-headstash",
              "type": "boolean"
            },
            "snip120u_code_hash": {
              "description": "The code hash of the snip120u contract, on Secret Network. Not optional for pre-deployment verification",
              "type": "string"
            },
            "snip120u_code_id": {
              "description": "The code ID of the snip120u contract, on Secret Network.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "token_params": {
              "description": "Params defined by deployer for tokens included.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/HeadstashTokenParams"
              }
            }
          },
          "additionalProperties": false
        },
        "HeadstashTokenParams": {
          "description": "Params for Headstash Tokens",
          "type": "object",
          "required": [
            "ibc",
            "name",
            "native",
            "source_channel",
            "symbol",
            "total"
          ],
          "properties": {
            "ibc": {
              "description": "ibc string on Secret",
              "type": "string"
            },
            "name": {
              "description": "Name to use in snip120u state",
              "type": "string"
            },
            "native": {
              "description": "native token name",
              "type": "string"
            },
            "snip_addr": {
              "description": "snip20 addr on Secret",
              "type": [
                "string",
                "null"
              ]
            },
            "source_channel": {
              "description": "canonical source channel of token for transfers from source to secret network",
              "type": "string"
            },
            "symbol": {
              "description": "Symbol to use",
              "type": "string"
            },
            "total": {
              "description": "Total amount for specific snip",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_deployment_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string"
    },
    "get_ica_contract_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "IcaContractState",
      "description": "IcaContractState is the state of the cw-ica-controller contract.",
      "type": "object",
      "required": [
        "contract_addr",
        "headstash_params"
      ],
      "properties": {
        "contract_addr": {
          "$ref": "#/definitions/Addr"
        },
        "headstash_params": {
          "$ref": "#/definitions/HeadstashParams"
        },
        "ica_state": {
          "anyOf": [
            {
              "$ref": "#/definitions/IcaState"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "BloomConfig": {
          "type": "object",
          "required": [
            "default_cadance",
            "max_granularity",
            "min_cadance"
          ],
          "properties": {
            "default_cadance": {
              "description": "minimum cadance before messages are eligible to be added to mempool (in blocks)",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "max_granularity": {
              "description": "maximum number of transactions a bloom msg will process",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "min_cadance": {
              "description": "minimum cadance that can be set before messages are eligible for mempool. if 0, default_cadance is set.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "ChannelState": {
          "description": "State is the state of the IBC application's channel. This application only supports one channel.",
          "type": "object",
          "required": [
            "channel",
            "channel_status"
          ],
          "properties": {
            "channel": {
              "description": "The IBC channel, as defined by cosmwasm.",
              "allOf": [
                {
                  "$ref": "#/definitions/IbcChannel"
                }
              ]
            },
            "channel_status": {
              "description": "The status of the channel.",
              "allOf": [
                {
                  "$ref": "#/definitions/ChannelStatus"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "ChannelStatus": {
          "description": "Status is the status of an IBC channel.",
          "oneOf": [
            {
              "description": "Uninitialized is the default state of the channel.",
              "type": "string",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED"
              ]
            },
            {
              "description": "Init is the state of the channel when it is created.",
              "type": "string",
              "enum": [
                "STATE_INIT"
              ]
            },
            {
              "description": "TryOpen is the state of the channel when it is trying to open.",
              "type": "string",
              "enum": [
                "STATE_TRYOPEN"
              ]
            },
            {
              "description": "Open is the state of the channel when it is open.",
              "type": "string",
              "enum": [
                "STATE_OPEN"
              ]
            },
            {
              "description": "Closed is the state of the channel when it is closed.",
              "type": "string",
              "enum": [
                "STATE_CLOSED"
              ]
            },
            {
              "description": "The channel has just accepted the upgrade handshake attempt and is flushing in-flight packets. Added in `ibc-go` v8.1.0.",
              "type": "string",
              "enum": [
                "STATE_FLUSHING"
              ]
            },
            {
              "description": "The channel has just completed flushing any in-flight packets. Added in `ibc-go` v8.1.0.",
              "type": "string",
              "enum": [
                "STATE_FLUSHCOMPLETE"
              ]
            }
          ]
        },
        "HeadstashInitConfig": {
          "type": "object",
          "required": [
            "claim_msg_plaintxt",
            "random_key"
          ],
          "properties": {
            "claim_msg_plaintxt": {
              "type": "string"
            },
            "end_date": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "random_key": {
              "type": "string"
            },
            "start_date": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "HeadstashParams": {
          "description": "Params for Headstash",
          "type": "object",
          "required": [
            "cw_glob",
            "headstash_init_config",
            "multiplier",
            "snip120u_code_hash",
            "snip120u_code_id",
            "token_params"
          ],
          "properties": {
            "bloom_config": {
              "description": "bloom config",
              "anyOf": [
                {
                  "$ref": "#/definitions/BloomConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "cw_glob": {
              "description": "The contract addr for cw-glob on the native chain.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "fee_granter": {
              "description": "The wallet address able to create feegrant authorizations on behalf of this contract",
              "type": [
                "string",
                "null"
              ]
            },
            "headstash_addr": {
              "description": "Headstash contract address this contract is admin of. We save this address in the first callback msg sent during setup_headstash, and then use it to set as admin for snip120u of assets after 1st callback.",
              "type": [
                "string",
                "null"
              ]
            },
            "headstash_code_id": {
              "description": "Code id of Headstash contract on Secret Network",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "headstash_init_config": {
              "$ref": "#/definitions/HeadstashInitConfig"
            },
            "multiplier": {
              "description": "Enables reward multiplier for cw-headstash",
              "type": "boolean"
            },
            "snip120u_code_hash": {
              "description": "The code hash of the snip120u contract, on Secret Network. Not optional for pre-deployment verification",
              "type": "string"
            },
            "snip120u_code_id": {
              "description": "The code ID of the snip120u contract, on Secret Network.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "token_params": {
              "description": "Params defined by deployer for tokens included.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/HeadstashTokenParams"
              }
            }
          },
          "additionalProperties": false
        },
        "HeadstashTokenParams": {
          "description": "Params for Headstash Tokens",
          "type": "object",
          "required": [
            "ibc",
            "name",
            "native",
            "source_channel",
            "symbol",
            "total"
          ],
          "properties": {
            "ibc": {
              "description": "ibc string on Secret",
              "type": "string"
            },
            "name": {
              "description": "Name to use in snip120u state",
              "type": "string"
            },
            "native": {
              "description": "native token name",
              "type": "string"
            },
            "snip_addr": {
              "description": "snip20 addr on Secret",
              "type": [
                "string",
                "null"
              ]
            },
            "source_channel": {
              "description": "canonical source channel of token for transfers from source to secret network",
              "type": "string"
            },
            "symbol": {
              "description": "Symbol to use",
              "type": "string"
            },
            "total": {
              "description": "Total amount for specific snip",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "IbcChannel": {
          "description": "IbcChannel defines all information on a channel. This is generally used in the hand-shake process, but can be queried directly.",
          "type": "object",
          "required": [
            "connection_id",
            "counterparty_endpoint",
            "endpoint",
            "order",
            "version"
          ],
          "properties": {
            "connection_id": {
              "description": "The connection upon which this channel was created. If this is a multi-hop channel, we only expose the first hop.",
              "type": "string"
            },
            "counterparty_endpoint": {
              "$ref": "#/definitions/IbcEndpoint"
            },
            "endpoint": {
              "$ref": "#/definitions/IbcEndpoint"
            },
            "order": {
              "$ref": "#/definitions/IbcOrder"
            },
            "version": {
              "description": "Note: in ibcv3 this may be \"\", in the IbcOpenChannel handshake messages",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "IbcEndpoint": {
          "type": "object",
          "required": [
            "channel_id",
            "port_id"
          ],
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "IbcOrder": {
          "description": "IbcOrder defines if a channel is ORDERED or UNORDERED Values come from https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/core/channel/v1/channel.proto#L69-L80 Naming comes from the protobuf files and go translations.",
          "type": "string",
          "enum": [
            "ORDER_UNORDERED",
            "ORDER_ORDERED"
          ]
        },
        "IcaState": {
          "description": "IcaState is the state of the ICA.",
          "type": "object",
          "required": [
            "channel_state",
            "ica_addr",
            "tx_encoding"
          ],
          "properties": {
            "channel_state": {
              "$ref": "#/definitions/ChannelState"
            },
            "ica_addr": {
              "type": "string"
            },
            "tx_encoding": {
              "$ref": "#/definitions/TxEncoding"
            }
          },
          "additionalProperties": false
        },
        "TxEncoding": {
          "description": "`TxEncoding` is the encoding of the transactions sent to the ICA host.",
          "oneOf": [
            {
              "description": "`Protobuf` is the protobuf serialization of the CosmosSDK's Any.",
              "type": "string",
              "enum": [
                "proto3"
              ]
            },
            {
              "description": "`Proto3Json` is the json serialization of the CosmosSDK's Any.",
              "type": "string",
              "enum": [
                "proto3json"
              ]
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "ownership": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Ownership_for_String",
      "description": "The contract's ownership info",
      "type": "object",
      "properties": {
        "owner": {
          "description": "The contract's current owner. `None` if the ownership has been renounced.",
          "type": [
            "string",
            "null"
          ]
        },
        "pending_expiry": {
          "description": "The deadline for the pending owner to accept the ownership. `None` if there isn't a pending ownership transfer, or if a transfer exists and it doesn't have a deadline.",
          "anyOf": [
            {
              "$ref": "#/definitions/Expiration"
            },
            {
              "type": "null"
            }
          ]
        },
        "pending_owner": {
          "description": "The account who has been proposed to take over the ownership. `None` if there isn't a pending ownership transfer.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
